  ---
    layout: default
    title: Dev102's Challenge #10 - The Missing Number
    ---

  <p>I didn't actually skip last week's challenge for Dev102.  I did write up a solution.  I just forgot to post it.  It was wrong anyway.</p>  <p>Well, no sense it looking backward... <a href="http://www.dev102.com/net/a-programming-job-interview-challenge-10-the-missing-number/">This week's</a>:</p>  <blockquote>   <p><em>Your input is an unsorted list of n numbers ranging from 1 to n+1, all of the numbers are unique, meaning that a number can’t appear twice in that list. ..One of the numbers is missing and you are asked to provide the most efficient method to find that missing number.</em></p> </blockquote>  <p>And Shahar was right, it was rather easy.  We just add up the number we get, and subtract that value from the sum we should have gotten if the missing number wasn't missing.</p>  <p>int FindMissingNumber(IEnumerable&lt;int&gt; list)    <br />{     <br />    int actualSum = 0;     <br />    int expectedSum = 0;     <br />    int n = 1;     <br />    foreach(int i in list)     <br />    {     <br />        actualSum += i;     <br />        expectedSum += n++;     <br />    }     <br />    expectedSum += n;     <br />    return expectedSum - actualSum;     <br />} </p>  <p> </p>  <p>Things to note:</p>  <ul>   <li>The complexity of the algorithm in O(n).   </li>    <li>I  assured that complexity by using the least powerful collection interface (IEnumerable), and iterated through it only once. </li>    <li>I summed the expected total manually instead of an formula on list.Count, but for some collection types (such as a linked lists) Count is, by itself, O(n). </li>    <li>The method will work for an empty sequence, returning 1. </li> </ul>