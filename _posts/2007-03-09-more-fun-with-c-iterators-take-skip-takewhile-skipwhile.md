---
layout: post
title: More Fun with C# Iterators:Take, Skip, TakeWhile, SkipWhile
categories: code c# .net programming generics-without-collections
tags: code c# .net programming generics-without-collections
---

  <p>As I was reading <a href="http://gbarnett.org/archive/2007/03/08/linq-standard-query-operators-part-3.aspx">this article by Granville Barnett</a> on some of the new operators available on LINQ queries, I thought, "That's all well and good, but for the time being, we're living in a .Net 2.0 world.  I wonder if I could emulate those with just generics &amp; iterators "  As it turned out, it was quite easy.</p> <p>First up is Take:  Given a collection, we want to return the subset which is just the first N items.  To handle this, we just return items while counting down to zero. When we reach zero, we stop.  </p> <p> </p><div class="csharpcode"><pre class="alt">        <span class="kwrd">static</span> <span class="kwrd">public</span> IEnumerable&lt;T&gt; Take&lt;T&gt;(IEnumerable&lt;T&gt; enm, <span class="kwrd">int</span> take)</pre><pre>        {</pre><pre class="alt">            <span class="kwrd">foreach</span> (T t <span class="kwrd">in</span> enm)</pre><pre>            {</pre><pre class="alt">                <span class="kwrd">if</span> (take-- == 0)</pre><pre>                    <span class="kwrd">break</span>;</pre><pre class="alt">                <span class="kwrd">yield</span> <span class="kwrd">return</span> t;</pre><pre>            } <span class="rem">// foreach </span></pre><pre class="alt">         }</pre></div>
<p></p>
<p>
</p><div class="csharpcode"><pre class="alt">            <span class="kwrd">string</span>[] peopleinit = <span class="kwrd">new</span> <span class="kwrd">string</span>[] { <span class="str">"Granville"</span>, <span class="str">"Rachel"</span>, <span class="str">"Monica"</span>, <span class="str">"John"</span>, <span class="str">"Ross"</span>, <span class="str">"Joey"</span> };</pre><pre>            List&lt;<span class="kwrd">string</span>&gt; people = <span class="kwrd">new</span> List&lt;<span class="kwrd">string</span>&gt;(peopleinit);</pre><pre class="alt"> </pre><pre>            Console.WriteLine(<span class="str">"Take Test...."</span>);</pre><pre class="alt">            <span class="kwrd">foreach</span> (<span class="kwrd">string</span> person <span class="kwrd">in</span> Iter.Take(people, 2))</pre><pre>            {</pre><pre class="alt">                Console.WriteLine(person);   <span class="rem">// Prints  Granville, Rachel</span></pre><pre>            }</pre></div>
<p></p>
<p>Next, is Skip.  This is essentially the reverse of Take: Given a collection, we want to return the subset which is everything after the first N items.  And handling Skip is essnetially the reverse of Take as well:  We still count down to zero as we iterator through the collection, but we don't return anything until we reach zero.  (Of course, after we reach zero, we have to stop decrementing the count, or the if() will fail when skip equal -1.)</p>
<p>
</p><div class="csharpcode"><pre class="alt"><span class="kwrd">static</span> <span class="kwrd">public</span> IEnumerable&lt;T&gt; Skip&lt;T&gt;(IEnumerable&lt;T&gt; enm, <span class="kwrd">int</span> skip)</pre><pre>{</pre><pre class="alt">    <span class="kwrd">foreach</span> (T t <span class="kwrd">in</span> enm)</pre><pre>    {</pre><pre class="alt">        <span class="kwrd">if</span> (skip == 0)</pre><pre>            <span class="kwrd">yield</span> <span class="kwrd">return</span> t;</pre><pre class="alt">        <span class="kwrd">else</span></pre><pre>            --skip;</pre><pre class="alt">    } <span class="rem">// foreach </span></pre><pre>}</pre></div>
<p></p>
<p>
</p><div class="csharpcode"><pre class="alt">Console.WriteLine(<span class="str">"Skip Test...."</span>);</pre><pre><span class="kwrd">foreach</span> (<span class="kwrd">string</span> person <span class="kwrd">in</span> Iter.Skip(people, 4))</pre><pre class="alt">{</pre><pre>    Console.WriteLine(person);   <span class="rem">// Prints  Ross, Joey</span></pre><pre class="alt">}</pre></div>
<p></p>
<p>Now, once we have Skip, SkipFirst (<a href="http://honestillusion.com/blogs/blog_0/archive/2007/02/05/c-code-adding-skip-first-to-foreach.aspx">which we discussed before)</a> just become an instance of that. </p>
<p>
</p><div class="csharpcode"><pre class="alt"><span class="kwrd">static</span> <span class="kwrd">public</span> IEnumerable&lt;T&gt; SkipFirst&lt;T&gt;(IEnumerable&lt;T&gt; enm)</pre><pre>{</pre><pre class="alt">    <span class="kwrd">return</span> Skip(enm, 1);</pre><pre>} </pre></div>
<p></p>
<p>There is no simple way to expand SkipLast, which was also discussed in that previous article, beyond just one item, so we'll leave it's implementation.</p>
<p>A bit more advanced are TakeWhile and SkipWhile.  And, unlike the LINQ versions, we can't use lambda expression, so we'll have to make do with delagates.</p>
<p>The essense of TakeWhile is, given a collection, we return items until we reach one which fails a given predicate.  Note that we stop at the first failure we reach (even if there may be later item which pass the predicate test)</p>
<p>
</p><div class="csharpcode"><pre class="alt"><span class="kwrd">public</span> <span class="kwrd">delegate</span> <span class="kwrd">bool</span> whilecond&lt;T&gt;(T t);</pre><pre> </pre><pre class="alt"><span class="kwrd">static</span> <span class="kwrd">public</span> IEnumerable&lt;T&gt; TakeWhile&lt;T&gt;(IEnumerable&lt;T&gt; enm, whilecond&lt;T&gt; take)</pre><pre>{</pre><pre class="alt">      <span class="kwrd">foreach</span> (T t <span class="kwrd">in</span> enm)</pre><pre>    {</pre><pre class="alt">        <span class="kwrd">if</span> (take(t))</pre><pre>            <span class="kwrd">yield</span> <span class="kwrd">return</span> t;</pre><pre class="alt">        <span class="kwrd">else</span></pre><pre>            <span class="kwrd">break</span>;</pre><pre class="alt"> </pre><pre>    } <span class="rem">// foreach </span></pre><pre class="alt"> </pre><pre>}</pre></div>
<p></p>
<p>
</p><div class="csharpcode"><pre class="alt"><span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">bool</span> LongerThan5(<span class="kwrd">string</span> a)</pre><pre>{</pre><pre class="alt">    <span class="kwrd">return</span> a.Length &gt; 5;</pre><pre>}</pre><pre class="alt">        <span class="rem">// :</span></pre><pre>        <span class="rem">//:</span></pre><pre class="alt">        </pre><pre> Console.WriteLine(<span class="str">"TakeWhile Test...."</span>);</pre><pre class="alt"><span class="kwrd">foreach</span> (<span class="kwrd">string</span> person <span class="kwrd">in</span> Iter.TakeWhile(people, LongerThan5))</pre><pre>{</pre><pre class="alt">    Console.WriteLine(person);   <span class="rem">// Prints  Granville, "Rachel", "Monica", </span></pre><pre>}</pre></div>
<p></p>
<p> </p>
<p>Final, this brings us to SkipWhile, which is the inverse of TakeWhile:  Given a collection, we skip items until one fails a given predicate, and then we return the rest (even though some of the rest may fail the predicate)</p>
<p>
</p><div class="csharpcode"><pre class="alt"><span class="kwrd">static</span> <span class="kwrd">public</span> IEnumerable&lt;T&gt; SkipWhile&lt;T&gt;(IEnumerable&lt;T&gt; enm, whilecond&lt;T&gt; skip)</pre><pre>{</pre><pre class="alt">    <span class="kwrd">bool</span> doneskipping = <span class="kwrd">false</span>;</pre><pre>    <span class="kwrd">foreach</span> (T t <span class="kwrd">in</span> enm)</pre><pre class="alt">    {</pre><pre>        <span class="kwrd">if</span> (doneskipping || !skip(t))</pre><pre class="alt">        {</pre><pre>            doneskipping = <span class="kwrd">true</span>;</pre><pre class="alt">            <span class="kwrd">yield</span> <span class="kwrd">return</span> t;</pre><pre>         } <span class="rem">// else</span></pre><pre class="alt"> </pre><pre>    } <span class="rem">// foreach </span></pre><pre class="alt">}</pre></div>
<p></p>
<p>
</p><div class="csharpcode"><pre class="alt"> </pre><pre>Console.WriteLine(<span class="str">"SkipWhile Test...."</span>);</pre><pre class="alt"><span class="kwrd">foreach</span> (<span class="kwrd">string</span> person <span class="kwrd">in</span> Iter.SkipWhile(people, LongerThan5))</pre><pre>{</pre><pre class="alt">    Console.WriteLine(person);   <span class="rem">// Prints  "John", "Ross", "Joey" </span></pre><pre>}</pre></div>
<p></p>
<p> </p>
<p> </p><a href="http://www.dotnetkicks.com/kick/?url=http://honestillusion.com/blogs/blog_0/archive/2007/03/09/more-fun-with-c-iterators-take-skip-takewhile-skipwhile.aspx"><img alt="kick it on DotNetKicks.com" src="http://www.dotnetkicks.com/Services/Images/KickItImageGenerator.ashx?url=http://honestillusion.com/blogs/blog_0/archive/2007/03/09/more-fun-with-c-iterators-take-skip-takewhile-skipwhile.aspx" border="0" /></a>